/**
 * MIT License
 *
 * Copyright (C) 2024 Huawei Device Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook {
namespace react {

struct Stroke {
    std::string color;
    Float width;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value, Stroke &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_color = map.find("color");
    if (tmp_color != map.end()) {
        fromRawValue(context, tmp_color->second, result.color);
    }
    auto tmp_width = map.find("width");
    if (tmp_width != map.end()) {
        fromRawValue(context, tmp_width->second, result.width);
    }
}

static inline std::string toString(const Stroke &value) { return "[Object Stroke]"; }

struct Location {
    Float latitude;
    Float longitude;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value, Location &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_latitude = map.find("latitude");
    if (tmp_latitude != map.end()) {
        fromRawValue(context, tmp_latitude->second, result.latitude);
    }
    auto tmp_longitude = map.find("longitude");
    if (tmp_longitude != map.end()) {
        fromRawValue(context, tmp_longitude->second, result.longitude);
    }
}

static inline std::string toString(const Location &value) { return "[Object Location]"; }

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                std::vector<Location> &result) {
    auto items = (std::vector<RawValue>)value;
    for (const auto &item : items) {
        Location newItem;
        fromRawValue(context, item, newItem);
        result.emplace_back(newItem);
    }
}

struct BaiduMapOverlayHeatMapGradientStruct {
    std::vector<std::string> colors;
    std::vector<Float> startPoints;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                BaiduMapOverlayHeatMapGradientStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_colors = map.find("colors");
    if (tmp_colors != map.end()) {
        fromRawValue(context, tmp_colors->second, result.colors);
    }
    auto tmp_startPoints = map.find("startPoints");
    if (tmp_startPoints != map.end()) {
        fromRawValue(context, tmp_startPoints->second, result.startPoints);
    }
}

static inline std::string toString(const BaiduMapOverlayHeatMapGradientStruct &value) {
    return "[Object BaiduMapOverlayHeatMapGradientStruct]";
}

struct BaiduMapOverlayMarkerIconStruct {
    std::string uri;
    std::string bundle;
    std::string method;
    std::string body;
    Float width;
    Float height;
    Float scale;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                BaiduMapOverlayMarkerIconStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_uri = map.find("uri");
    if (tmp_uri != map.end()) {
        fromRawValue(context, tmp_uri->second, result.uri);
    }
    auto tmp_bundle = map.find("bundle");
    if (tmp_bundle != map.end()) {
        fromRawValue(context, tmp_bundle->second, result.bundle);
    }
    auto tmp_method = map.find("method");
    if (tmp_method != map.end()) {
        fromRawValue(context, tmp_method->second, result.method);
    }
    auto tmp_body = map.find("body");
    if (tmp_body != map.end()) {
        fromRawValue(context, tmp_body->second, result.body);
    }
    auto tmp_width = map.find("width");
    if (tmp_width != map.end()) {
        fromRawValue(context, tmp_width->second, result.width);
    }
    auto tmp_height = map.find("height");
    if (tmp_height != map.end()) {
        fromRawValue(context, tmp_height->second, result.height);
    }
    auto tmp_scale = map.find("scale");
    if (tmp_scale != map.end()) {
        fromRawValue(context, tmp_scale->second, result.scale);
    }
}

static inline std::string toString(const BaiduMapOverlayMarkerIconStruct &value) {
    return "[Object BaiduMapOverlayMarkerIconStruct]";
}

class BaiduMapOverlayArcProps final : public ViewProps {
public:
    BaiduMapOverlayArcProps() = default;
    BaiduMapOverlayArcProps(const PropsParserContext &context, const BaiduMapOverlayArcProps &sourceProps,
                            const RawProps &rawProps);

#pragma mark - Props

    bool dash{false};
    Stroke stroke{};
    std::vector<Location> points{};
};

class BaiduMapOverlayCircleProps final : public ViewProps {
public:
    BaiduMapOverlayCircleProps() = default;
    BaiduMapOverlayCircleProps(const PropsParserContext &context, const BaiduMapOverlayCircleProps &sourceProps,
                               const RawProps &rawProps);

#pragma mark - Props

    Float radius{0.0};
    std::string fillColor{};
    Stroke stroke{};
    Location center{};
};

class BaiduMapOverlayClusterProps final : public ViewProps {
public:
    BaiduMapOverlayClusterProps() = default;
    BaiduMapOverlayClusterProps(const PropsParserContext &context, const BaiduMapOverlayClusterProps &sourceProps,
                                const RawProps &rawProps);

#pragma mark - Props
};

class BaiduMapOverlayHeatMapProps final : public ViewProps {
public:
    BaiduMapOverlayHeatMapProps() = default;
    BaiduMapOverlayHeatMapProps(const PropsParserContext &context, const BaiduMapOverlayHeatMapProps &sourceProps,
                                const RawProps &rawProps);

#pragma mark - Props

    std::vector<Location> points{};
    BaiduMapOverlayHeatMapGradientStruct gradient{};
};

class BaiduMapOverlayInfoWindowProps final : public ViewProps {
public:
    BaiduMapOverlayInfoWindowProps() = default;
    BaiduMapOverlayInfoWindowProps(const PropsParserContext &context, const BaiduMapOverlayInfoWindowProps &sourceProps,
                                   const RawProps &rawProps);

#pragma mark - Props

    Float offsetY{0.0};
};

class BaiduMapOverlayMarkerIconProps final : public ViewProps {
public:
    BaiduMapOverlayMarkerIconProps() = default;
    BaiduMapOverlayMarkerIconProps(const PropsParserContext &context, const BaiduMapOverlayMarkerIconProps &sourceProps,
                                   const RawProps &rawProps);

#pragma mark - Props
};

class BaiduMapOverlayMarkerProps final : public ViewProps {
public:
    BaiduMapOverlayMarkerProps() = default;
    BaiduMapOverlayMarkerProps(const PropsParserContext &context, const BaiduMapOverlayMarkerProps &sourceProps,
                               const RawProps &rawProps);

#pragma mark - Props

    std::string title{};
    Float titleOffsetY{0.0};
    Location location{};
    bool perspective{false};
    bool flat{false};
    Float rotate{0.0};
    BaiduMapOverlayMarkerIconStruct icon{};
    std::string animateType{};
    Float alpha{0.0};
    std::string pinColor{};
};

class BaiduMapOverlayPolygonProps final : public ViewProps {
public:
    BaiduMapOverlayPolygonProps() = default;
    BaiduMapOverlayPolygonProps(const PropsParserContext &context, const BaiduMapOverlayPolygonProps &sourceProps,
                                const RawProps &rawProps);

#pragma mark - Props

    std::string fillColor{};
    Stroke stroke{};
    std::vector<Location> points{};
};

class BaiduMapOverlayPolylineProps final : public ViewProps {
public:
    BaiduMapOverlayPolylineProps() = default;
    BaiduMapOverlayPolylineProps(const PropsParserContext &context, const BaiduMapOverlayPolylineProps &sourceProps,
                                 const RawProps &rawProps);

#pragma mark - Props

    Stroke stroke{};
    std::vector<Location> points{};
};

class BaiduMapOverlayTextProps final : public ViewProps {
public:
    BaiduMapOverlayTextProps() = default;
    BaiduMapOverlayTextProps(const PropsParserContext &context, const BaiduMapOverlayTextProps &sourceProps,
                             const RawProps &rawProps);

#pragma mark - Props

    std::string text{};
    Float fontSize{0.0};
    std::string fontColor{};
    std::string bgColor{};
    Float rotate{0.0};
    Location location{};
};

class BaiduMapViewProps final : public ViewProps {
public:
    BaiduMapViewProps() = default;
    BaiduMapViewProps(const PropsParserContext &context, const BaiduMapViewProps &sourceProps,
                      const RawProps &rawProps);

#pragma mark - Props

    bool zoomControlsVisible{false};
    bool trafficEnabled{false};
    bool baiduHeatMapEnabled{false};
    bool zoomGesturesEnabled{false};
    bool scrollGesturesEnabled{false};
    Float mapType{0.0};
    Float zoom{0.0};
    bool showsUserLocation{false};
    Location locationData{};
    Location center{};
};

} // namespace react
} // namespace facebook
